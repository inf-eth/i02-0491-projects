/*
# Vulnerability.cpp
#
# Copyright (c) 2012 Attique Dawood, Awais Aslam
#
# This file is part of Vulnerability program provided with Automated Worm Fingerprinting.
#
# This software is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.
#
#################################################################################
Getting Hostname: http://guy-lecky-thompson.suite101.com/socket-programming-gethostbyname-a19557
*/

#include <Vulnerability.h>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <iostream>
#include <string>
#include <bitset>
#include <vector>
#include <sstream>
#include <fstream>

#ifdef WIN32
#include <WinSock2.h>
#include <process.h>
#include <Windows.h>
#else
#include <arpa/inet.h>		// inet_ntoa()
#include <netdb.h>			// gethostbyname(), connect(), send(), recv()
#include <pthread.h>
#endif

using std::cerr;
using std::cout;
using std::endl;
using std::fill;
using std::string;
using std::bitset;
using std::vector;
using std::stringstream;
using std::fstream;

// Platform specific #defines
#ifdef WIN32
#define THREAD_RETURN_TYPE void
#define CLOSE closesocket

#else
#define THREAD_RETURN_TYPE void*
#define CLOSE close
#endif

// Threads.
THREAD_RETURN_TYPE Vulnerability (void *);
THREAD_RETURN_TYPE Worm_V01 (void *);
THREAD_RETURN_TYPE Worm_V02 (void *);

#ifdef WIN32
HANDLE tVulnerability;
HANDLE tWorm_V01;
HANDLE tWorm_V02;
HANDLE MutexLock = CreateMutex (NULL, FALSE, NULL);
#else
pthread_t tVulnerability;
pthread_t tWorm_V01;
pthread_t tWorm_V02;
pthread_mutex_t MutexLock = PTHREAD_MUTEX_INITIALIZER;
#endif

// Network related.
// ****************************************** #Defintions ***********************************************
#define  MAXBUFFERSIZE	512		// Maximum default buffersize.
#define  SERVERPORT		7010	// Vulnerability Server thread will be listening on this port by default.
// ******************************************************************************************************

// *********************************************** Globals ************************************************
int SocketFD;

//struct hostent *he;
struct sockaddr_in ServerAddress;
struct sockaddr_in ClientAddress;

// Buffer.
char Buffer[MAXBUFFERSIZE];
int NumOfBytesSent;
int NumOfBytesReceived;

// Miscellaneous Variables.
int Yes = 1;
int AddressLength;
int errorcheck;
#ifdef WIN32
int sin_size;
#else
socklen_t sin_size;
#endif

// Global Vulnerability object.
CVulnerability VulnerabilityInstance;

CVulnerability::CVulnerability(): Mode(MODE_NORMAL)
{
}

void CVulnerability::Initialize(MODE_OF_OPERATION pMode)
{
	Mode = pMode;
	switch(Mode)
	{
		case MODE_NORMAL: default:
		{
			InfectionFlags |= MODE_INFECTED_NONE_FLAG;
			break;
		}
		case MODE_INFECTED_V01:
		{
			InfectionFlags |= MODE_INFECTED_V01_FLAG;
			break;
		}
		case MODE_INFECTED_V02:
		{
			InfectionFlags |= MODE_INFECTED_V02_FLAG;
			break;
		}
		case MODE_INFECTED_ALL:
		{
			InfectionFlags |= MODE_INFECTED_ALL_FLAG;
			break;
		}
	}

	#ifdef WIN32
	WSADATA wsaData;
	if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)
	{
		cerr << "WSAStartup failed." << endl;
		exit(1);
	}
	#endif

	// Server socket.
	SafeCall (SocketFD = socket (AF_INET, SOCK_DGRAM, 0), "socket()");
	// Server address initialization for binding.
	ServerAddress.sin_family = AF_INET;				// Socekt family.
	ServerAddress.sin_addr.s_addr = INADDR_ANY;		// Setting server IP. INADDR_ANY is the localhost IP.
	ServerAddress.sin_port = htons (SERVERPORT);	// Setting server port.
	fill ((char*)&(ServerAddress.sin_zero), (char*)&(ServerAddress.sin_zero)+8, '\0');

	// bind()
	SafeCall (bind (SocketFD, (sockaddr *)&ServerAddress, sizeof (ServerAddress)), "bind()");

}

void CVulnerability::Run()
{
	cout << "=======================================================" << endl;
	// Infected Threads.
	// Check for Worm_V01 infection:
	if (InfectionFlags[0] == 1)
	{
		cout << "Starting infection thread Worm_V01..." << endl;
		#ifdef WIN32
		tWorm_V01 = (HANDLE)_beginthread (Worm_V01, 0, NULL);
		#else
		pthread_create (&tWorm_V01, NULL, Worm_V01, NULL);
		#endif
	}
	// Check for Worm_V02 infection:
	if (InfectionFlags[1] == 1)
	{
		cout << "Starting infection thread Worm_V02..." << endl;
		#ifdef WIN32
		tWorm_V02 = (HANDLE)_beginthread (Worm_V02, 0, NULL);
		#else
		pthread_create (&tWorm_V02, NULL, Worm_V02, NULL);
		#endif
	}

	char HostName[255];
	gethostname(HostName, 255);
	cout << "Hostname: " << HostName << endl;

	cout << "Starting Vulnerability Server 1.00..." << endl;
	cout << "Server Address: " << inet_ntoa(*(in_addr *)*gethostbyname (HostName)->h_addr_list) << ":" << SERVERPORT << endl;
	time_t rawtime;
	time ( &rawtime );
	cout << "Today is: " << asctime (localtime (&rawtime));

	// Create Vulnerability Thread.
	#ifdef WIN32
	tVulnerability = (HANDLE)_beginthread (Vulnerability, 0, NULL);
	WaitForSingleObject (tVulnerability, INFINITE);
	#else
	pthread_create (&tVulnerability, NULL, Vulnerability, NULL);
	pthread_join (tVulnerability, NULL);
	#endif
}

void SafeCall (int returnvalue, const char *FunctionName, int errorvalue)
{
	if (returnvalue == errorvalue)
	{
		cerr << "ERROR: " << FunctionName << endl;
		exit (-1);
	}
}

void SafeCallAssert (int returnvalue, const char *FunctionName, int expectedvalue)
{
	if (returnvalue != expectedvalue)
	{
		cerr << "ERROR: " << FunctionName << endl;
		exit (-1);
	}
}

// Threads.
THREAD_RETURN_TYPE Vulnerability (void *arg)
{
	while (true)
	{
		sin_size = sizeof (ClientAddress);
		SafeCall (NumOfBytesReceived = recvfrom (SocketFD, Buffer, MAXBUFFERSIZE-1, 0, (sockaddr *)&ClientAddress, &sin_size), "recvfrom()");
		Buffer[NumOfBytesReceived] = '\0';

		time_t rawtime;
		time ( &rawtime );
		cout << "=======================================================" << endl;
		cout << "Date/Time: " << asctime (localtime (&rawtime));
		cout << "Received : " << Buffer << endl;

		// Lock.
		#ifdef WIN32
		WaitForSingleObject (MutexLock, INFINITE);
		#else
		pthread_mutex_lock (&MutexLock);
		#endif
		
		// Check for Worm_V01 infection:
		if (VulnerabilityInstance.InfectionFlags[0] == 0 && strcmp(Buffer, WORM_V01_INFECTION) == 0)
		{
			cout << "INFECTION: Got infected with Worm_V01..." << endl;
			VulnerabilityInstance.InfectionFlags[0] = 1;
			#ifdef WIN32
			tWorm_V01 = (HANDLE)_beginthread (Worm_V01, 0, NULL);
			#else
			pthread_create (&tWorm_V01, NULL, Worm_V01, NULL);
			#endif
		}
		// Check for Worm_V02 infection:
		if (VulnerabilityInstance.InfectionFlags[1] == 0 && strstr(Buffer, WORM_V02_INFECTION) != NULL)
		{
			cout << "INFECTION: Got infected with Worm_V02..." << endl;
			VulnerabilityInstance.InfectionFlags[1] = 1;
			#ifdef WIN32
			tWorm_V02 = (HANDLE)_beginthread (Worm_V02, 0, NULL);
			#else
			pthread_create (&tWorm_V02, NULL, Worm_V02, NULL);
			#endif
		}

		// Unlock.
		#ifdef WIN32
		ReleaseMutex (MutexLock);
		#else
		pthread_mutex_unlock (&MutexLock);
		#endif
	}
	#ifndef WIN32
	return NULL;
	#endif
}

THREAD_RETURN_TYPE Worm_V01 (void *arg)
{
	// *********************************************** Network Related ************************************************
	#define W_V01_MAXBUFFERSIZE				512		// Maximum default buffersize.
	#define W_V01_PORT						7011	// Worm_V01 Port.
	#define W_V01_SUBNET_ATTACK_INTERVAL	10		// Wait this much time before attacking another subnet.
	#define W_V01_IP_ATTACK_INTERVAL		1		// Wait this much time before attacking another IP.
	
	//int W_V01_AddressLength;
	int W_V01_SocketFD;

	//struct hostent *W_V01_he;
	struct sockaddr_in W_V01_TheirAddress;
	struct sockaddr_in W_V01_Address;

	// W_V01_'s Buffer.
	//char W_V01_Buffer[W_V01_MAXBUFFERSIZE];
	//int W_V01_NumOfBytesSent;
	//int W_V01_NumOfBytesReceived;
	// ****************************************************************************************************************
	
	vector<string> SubnetList;
	stringstream AttackIPss;
	string AttackIP;

	fstream SubnetListIn("Worm_V01_Subnets.txt", std::ios::in);
	SubnetListIn.seekg(0, std::ios::end);
	int InFileSize = (int)SubnetListIn.tellg();
	if (!SubnetListIn || InFileSize < 0)
	{
		cerr << "ERROR: Opening file: Worm_V01_Subnets.txt" << endl;
		exit(-1);
	}
	SubnetListIn.seekg(std::ios::beg);

	string tempstring;
	while (!SubnetListIn.eof())
	{
		getline(SubnetListIn, tempstring, '\n');
		//if (SubnetListIn.eof())
			//break;
		cout << "Read: " << tempstring << endl;
		SubnetList.push_back(tempstring);
	}
	SubnetListIn.close();

	// Network Initialization.
	SafeCall(W_V01_SocketFD = socket(AF_INET, SOCK_DGRAM, 0), "socket()");
	W_V01_Address.sin_family = AF_INET;					// Socket family.
	W_V01_Address.sin_addr.s_addr = INADDR_ANY;			// Assigninig client IP.
	W_V01_Address.sin_port = htons(W_V01_PORT);			// W_V01_PORT.
	fill ((char*)&(W_V01_Address.sin_zero), (char*)&(W_V01_Address.sin_zero)+8, '\0');
	SafeCall(bind (W_V01_SocketFD, (sockaddr *)&W_V01_Address, sizeof (W_V01_Address)), "bind()");

	while (true)
	{
		// Attack all range of IPs in the subnet.
		for (int s=0; s < (int)SubnetList.size(); s++)
		{
			for (int i=1; i<255; i++)
			{
				if (i%5 == 0)
				{
					#ifdef WIN32
					Sleep (W_V01_IP_ATTACK_INTERVAL*1000);
					#else
					sleep (W_V01_IP_ATTACK_INTERVAL);
					#endif
				}

				// Generate an IP from subnet list.
				AttackIPss.clear();
				AttackIPss << SubnetList[s] << i;
				AttackIPss >> AttackIP;
				cout << "Worm_V01 Attacking: " << AttackIP << endl;

				// Get an address/IP to attack.
				in_addr Their_addr;
				if (inet_aton(AttackIP.c_str(), &Their_addr) == 0)		// Invalid address.
					continue;
				W_V01_TheirAddress.sin_family = AF_INET;						// Socket family.
				W_V01_TheirAddress.sin_addr = Their_addr;						// Their name/IP.
				W_V01_TheirAddress.sin_port = htons(SERVERPORT);				// Server Port.
				fill ((char*)&(W_V01_TheirAddress.sin_zero), (char*)&(W_V01_TheirAddress.sin_zero)+8, '\0');

				// Sending infectious payload.
				SafeCall(sendto(W_V01_SocketFD, WORM_V01_INFECTION, strlen(WORM_V01_INFECTION), 0, (sockaddr *)&W_V01_TheirAddress, sizeof(W_V01_TheirAddress)), "sendto()");
			}
			#ifdef WIN32
			Sleep (W_V01_IP_ATTACK_INTERVAL*1000);
			#else
			sleep (W_V01_IP_ATTACK_INTERVAL);
			#endif

			// Reset subnet list and start over.
			if (s == (int)SubnetList.size()-1)
				s = 0;
		}
	}
	#ifndef WIN32
	return NULL;
	#endif
}

THREAD_RETURN_TYPE Worm_V02 (void *arg)
{
	while (true)
	{

	}
	#ifndef WIN32
	return NULL;
	#endif
}
