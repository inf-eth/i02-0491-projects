/*
# Vulnerability.cpp
#
# Copyright (c) 2012 Attique Dawood, Awais Aslam
#
# This file is part of Vulnerability program provided with Automated Worm Fingerprinting.
#
# This software is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.
#
#################################################################################
*/

#include <Vulnerability.h>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <bitset>
#include <iostream>

#ifdef WIN32
#include <WinSock2.h>
#include <process.h>
#include <Windows.h>
#else
#include <arpa/inet.h>		// inet_ntoa()
#include <netdb.h>			// gethostbyname(), connect(), send(), recv()
#include <pthread.h>
#endif

using std::bitset;
using std::cerr;
using std::cout;
using std::endl;
using std::fill;

// Platform specific #defines
#ifdef WIN32
#define THREAD_RETURN_TYPE void
#define CLOSE closesocket

#else
#define THREAD_RETURN_TYPE void*
#define CLOSE close
#endif

// Threads.
THREAD_RETURN_TYPE Vulnerability (void *);
THREAD_RETURN_TYPE Worm_V01 (void *);
THREAD_RETURN_TYPE Worm_V02 (void *);

#ifdef WIN32
HANDLE tVulnerability;
HANDLE tWorm_V01;
HANDLE tWorm_V02;
HANDLE MutexLock = CreateMutex (NULL, FALSE, NULL);
#else
pthread_t tVulnerability;
pthread_t tWorm_V01;
pthread_t tWorm_V02;
pthread_mutex_t MutexLock = PTHREAD_MUTEX_INITIALIZER;
#endif

// Network related.
// ****************************************** #Defintions ***********************************************
#define  MAXBUFFERSIZE	512		// Maximum default buffersize.
#define  SERVERPORT		7010	// Vulnerability Server thread will be listening on this port by default.
// ******************************************************************************************************

// *********************************************** Globals ************************************************
int SocketFD;

//struct hostent *he;
struct sockaddr_in ServerAddress;
struct sockaddr_in ClientAddress;

// Buffer.
char Buffer[MAXBUFFERSIZE];
int NumOfBytesSent;
int NumOfBytesReceived;

// Miscellaneous Variables.
int Yes = 1;
int AddressLength;
int errorcheck;
#ifdef WIN32
int sin_size;
#else
socklen_t sin_size;
#endif

// Global Vulnerability object.
CVulnerability VulnerabilityInstance;

CVulnerability::CVulnerability(): Mode(MODE_NORMAL)
{
}

void CVulnerability::Initialize(MODE_OF_OPERATION pMode)
{
	Mode = pMode;
	switch(Mode)
	{
		case MODE_NORMAL: default:
		{
			InfectionFlags |= MODE_INFECTED_NONE_FLAG;
			break;
		}
		case MODE_INFECTED_V01:
		{
			InfectionFlags |= MODE_INFECTED_V01_FLAG;
			break;
		}
		case MODE_INFECTED_V02:
		{
			InfectionFlags |= MODE_INFECTED_V02_FLAG;
			break;
		}
		case MODE_INFECTED_ALL:
		{
			InfectionFlags |= MODE_INFECTED_ALL_FLAG;
			break;
		}
	}

	#ifdef WIN32
	WSADATA wsaData;
	if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)
	{
		cerr << "WSAStartup failed." << endl;
		exit(1);
	}
	#endif

	// Server socket.
	SafeCall (SocketFD = socket (AF_INET, SOCK_DGRAM, 0), "socket()");
	// Server address initialization for binding.
	ServerAddress.sin_family = AF_INET;				// Socekt family.
	ServerAddress.sin_addr.s_addr = INADDR_ANY;		// Setting server IP. INADDR_ANY is the localhost IP.
	ServerAddress.sin_port = htons (SERVERPORT);	// Setting server port.
	fill ((char*)&(ServerAddress.sin_zero), (char*)&(ServerAddress.sin_zero)+8, '\0');

	// bind()
	SafeCall (bind (SocketFD, (sockaddr *)&ServerAddress, sizeof (ServerAddress)), "bind()");

}

void CVulnerability::Run()
{
	cout << "=======================================================" << endl;
	// Infected Threads.
	// Check for Worm_V01 infection:
	if (InfectionFlags[0] == 1)
	{
		cout << "Starting infection thread Worm_V01..." << endl;
		#ifdef WIN32
		tWorm_V01 = (HANDLE)_beginthread (Worm_V01, 0, NULL);
		#else
		pthread_create (&tWorm_V01, NULL, Worm_V01, NULL);
		#endif
	}
	// Check for Worm_V02 infection:
	if (InfectionFlags[1] == 1)
	{
		cout << "Starting infection thread Worm_V02..." << endl;
		#ifdef WIN32
		tWorm_V02 = (HANDLE)_beginthread (Worm_V02, 0, NULL);
		#else
		pthread_create (&tWorm_V02, NULL, Worm_V02, NULL);
		#endif
	}

	cout << "Starting Vulnerability Server 1.00..." << endl;
	cout << "Server Address: " << inet_ntoa(*(in_addr *)gethostbyname ("localhost")) << ":" << SERVERPORT << endl;
	time_t rawtime;
	time ( &rawtime );
	cout << "Today is: " << asctime (localtime (&rawtime));

	// Create Vulnerability Thread.
	#ifdef WIN32
	tVulnerability = (HANDLE)_beginthread (Vulnerability, 0, NULL);
	WaitForSingleObject (tVulnerability, INFINITE);
	#else
	pthread_create (&tVulnerability, NULL, Vulnerability, NULL);
	pthread_join (tVulnerability, NULL);
	#endif
}

void SafeCall (int returnvalue, const char *FunctionName, int errorvalue)
{
	if (returnvalue == errorvalue)
	{
		cerr << "ERROR: " << FunctionName << endl;
		exit (-1);
	}
}

void SafeCallAssert (int returnvalue, const char *FunctionName, int expectedvalue)
{
	if (returnvalue != expectedvalue)
	{
		cerr << "ERROR: " << FunctionName << endl;
		exit (-1);
	}
}

// Threads.
THREAD_RETURN_TYPE Vulnerability (void *arg)
{
	while (true)
	{
		sin_size = sizeof (ClientAddress);
		SafeCall (NumOfBytesReceived = recvfrom (SocketFD, Buffer, MAXBUFFERSIZE-1, 0, (sockaddr *)&ClientAddress, &sin_size), "recvfrom()");
		Buffer[NumOfBytesReceived] = '\0';

		time_t rawtime;
		time ( &rawtime );
		cout << "=======================================================" << endl;
		cout << "Date/Time: " << asctime (localtime (&rawtime));
		cout << "Message: " << Buffer << endl;

		// Lock.
		#ifdef WIN32
		WaitForSingleObject (MutexLock, INFINITE);
		#else
		pthread_mutex_lock (&MutexLock);
		#endif
		
		// Check for Worm_V01 infection:
		if (VulnerabilityInstance.InfectionFlags[0] == 0 && strcmp(Buffer, WORM_V01_INFECTION) == 0)
		{
			cout << "INFECTION: Got infected with Worm_V01..." << endl;
			VulnerabilityInstance.InfectionFlags[0] = 1;
			#ifdef WIN32
			tWorm_V01 = (HANDLE)_beginthread (Worm_V01, 0, NULL);
			#else
			pthread_create (&tWorm_V01, NULL, Worm_V01, NULL);
			#endif
		}
		// Check for Worm_V02 infection:
		if (VulnerabilityInstance.InfectionFlags[1] == 0 && strstr(Buffer, WORM_V02_INFECTION) != NULL)
		{
			cout << "INFECTION: Got infected with Worm_V02..." << endl;
			VulnerabilityInstance.InfectionFlags[1] = 1;
			#ifdef WIN32
			tWorm_V02 = (HANDLE)_beginthread (Worm_V02, 0, NULL);
			#else
			pthread_create (&tWorm_V02, NULL, Worm_V02, NULL);
			#endif
		}

		// Unlock.
		#ifdef WIN32
		ReleaseMutex (MutexLock);
		#else
		pthread_mutex_unlock (&MutexLock);
		#endif
	}
	#ifndef WIN32
	return NULL;
	#endif
}

THREAD_RETURN_TYPE Worm_V01 (void *arg)
{
	while (true)
	{

	}
	#ifndef WIN32
	return NULL;
	#endif
}

THREAD_RETURN_TYPE Worm_V02 (void *arg)
{
	while (true)
	{

	}
	#ifndef WIN32
	return NULL;
	#endif
}
