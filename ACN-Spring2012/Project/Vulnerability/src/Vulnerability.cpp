/*
# Vulnerability.cpp
#
# Copyright (c) 2012 Attique Dawood, Awais Aslam
#
# This file is part of Vulnerability program provided with Automated Worm Fingerprinting.
#
# This software is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.
#
#################################################################################
*/

#include <Vulnerability.h>
#include <cstdlib>
#include <bitset>
#include <iostream>

#ifdef WIN32
#include <process.h>
#include <Windows.h>
#include <WinSock2.h>
#else
#include <arpa/inet.h>		// inet_ntoa()
#include <netdb.h>			// gethostbyname(), connect(), send(), recv()
#include <pthread.h>
#endif

using std::bitset;
using std::cerr;
using std::cout;
using std::endl;
using std::fill;

// Platform specific #defines
#ifdef WIN32
#define THREAD_RETURN_TYPE void
#define CLOSE closesocket

#else
#define THREAD_RETURN_TYPE void*
#define CLOSE close
#endif

// Threads.
THREAD_RETURN_TYPE Vulnerability (void *);
THREAD_RETURN_TYPE Worm_V01 (void *);
THREAD_RETURN_TYPE Worm_V02 (void *);

#ifdef WIN32
HANDLE tVulnerability;
HANDLE tWorm_V01;
HANDLE tWorm_V02;
HANDLE MutexLock = CreateMutex (NULL, FALSE, NULL);
#else
pthread_t tVulnerability;
pthread_t tWorm_V01;
pthread_t tWorm_V02;
pthread_mutex_t MutexLock = PTHREAD_MUTEX_INITIALIZER;
#endif

// Network related.
// ****************************************** #Defintions ***********************************************
#define  MAXBUFFERSIZE	512		// Maximum default buffersize.
#define  SERVERPORT		7010	// Vulnerability Server thread will be listening on this port by default.
// ******************************************************************************************************

// *********************************************** Globals ************************************************
int SocketFD;

struct hostent *he;
struct sockaddr_in ServerAddress;
struct sockaddr_in ClientAddress;

// Buffer.
char Buffer[MAXBUFFERSIZE];
int NumOfBytesSent;
int NumOfBytesReceived;

// Miscellaneous Variables.
int Yes = 1;
int AddressLength;
int errorcheck;
#ifdef WIN32
int sin_size;
#else
socklen_t sin_size;
#endif

CVulnerability::CVulnerability(): Mode(MODE_NORMAL)
{
}

void CVulnerability::Initialize(MODE_OF_OPERATION pMode)
{
	Mode = pMode;
	switch(Mode)
	{
		case MODE_NORMAL: default:
		{
			InfectionFlags |= MODE_INFECTED_NONE_FLAG;
			cout << "InfectionFlags = " << InfectionFlags << endl;
			break;
		}
		case MODE_INFECTED_V01:
		{
			InfectionFlags |= MODE_INFECTED_V01_FLAG;
			cout << "InfectionFlags = " << InfectionFlags << endl;
			break;
		}
		case MODE_INFECTED_V02:
		{
			InfectionFlags |= MODE_INFECTED_V02_FLAG;
			cout << "InfectionFlags = " << InfectionFlags << endl;
			break;
		}
		case MODE_INFECTED_ALL:
		{
			InfectionFlags |= MODE_INFECTED_ALL_FLAG;
			cout << "InfectionFlags = " << InfectionFlags << endl;
			break;
		}
	}
	// Server socket.
	SafeCall (SocketFD = socket (AF_INET, SOCK_DGRAM, 0), "socket()");
	// Server address initialization for binding.
	ServerAddress.sin_family = AF_INET;				// Socekt family.
	ServerAddress.sin_addr.s_addr = INADDR_ANY;		// Setting server IP. INADDR_ANY is the localhost IP.
	ServerAddress.sin_port = htons (SERVERPORT);	// Setting server port.
	fill ((char*)&(ServerAddress.sin_zero), (char*)&(ServerAddress.sin_zero)+8, '\0');

	// bind()
	SafeCall (bind (SocketFD, (sockaddr *)&ServerAddress, sizeof (ServerAddress)), "bind()");
}

void CVulnerability::Run()
{
	// TODO: Create Normal Thread.
	
	// TODO: Creat Infected Threads.
}

void SafeCall (int returnvalue, const char *FunctionName, int errorvalue)
{
	if (returnvalue == errorvalue)
	{
		cerr << "ERROR: " << FunctionName << endl;
		exit (-1);
	}
}

void SafeCallAssert (int returnvalue, const char *FunctionName, int expectedvalue)
{
	if (returnvalue != expectedvalue)
	{
		cerr << "ERROR: " << FunctionName << endl;
		exit (-1);
	}
}

// Threads.
THREAD_RETURN_TYPE Vulnerability (void *arg)
{
	while (true)
	{
		sin_size = sizeof (ClientAddress);
		SafeCall (NumOfBytesReceived = recvfrom (SocketFD, Buffer, MAXBUFFERSIZE-1, 0, (sockaddr *)&ClientAddress, &sin_size), "recvfrom()");

		#ifdef WIN32
		WaitForSingleObject (MutexLock, INFINITE);
		//Process
		ReleaseMutex (MutexLock);
		#else
		pthread_mutex_lock (&MutexLock);
		//Process
		pthread_mutex_unlock (&MutexLock);
		#endif
	}
	#ifndef WIN32
	return NULL;
	#endif
}

THREAD_RETURN_TYPE Worm_V01 (void *arg)
{
	while (true)
	{

	}
	#ifndef WIN32
	return NULL;
	#endif
}

THREAD_RETURN_TYPE Worm_V02 (void *arg)
{
	while (true)
	{

	}
	#ifndef WIN32
	return NULL;
	#endif
}
