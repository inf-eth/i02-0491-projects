\documentclass[11pt,a4paper]{article}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{multirow}
\usepackage{url}
\usepackage{hyperref}	% Clickable links to figures, references and urls.
\usepackage{graphicx}
\usepackage{basicobjpgftikz}	% Custom basic shapes using pgf/tikz.

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\headheight}{12pt}
\setlength{\headsep}{60pt}
\setlength{\topmargin}{-90pt}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{10in}

\begin{document}

\title{Objects and Capabilities in Amoeba}
\author{Attique Dawood}
\maketitle

\section{Introduction to Amoeba Operating System}

Amoeba is a distributed operating system developed at Vrije Universiteit, Amsterdam in the eighties. Chief designer was Andrew S. Tanenbaum. The architecture can be described as a composition of workstations, terminals, processor pool and servers connected through LAN (figure~\ref{amoeba-architecture}). Servers are responsible for file management, printers, login authentication and database etc.

It was designed to be transparent with user not having to worry about underlying hardware, like number of processors. The user only sees interacting with a single powerful system~\cite{amoeba-sourceforge}. Another important design goal was to have an \emph{object-based} resource management~\cite{distributed-systems-book} where each resource is regarded as an object.

\begin{figure}[here]
\centering
\begin{tikzpicture}

\draw[line width=1.5pt] (3,0) -- (0.6,4);
\draw[line width=1.5pt] (3,0) -- (2.6,4);
\draw[line width=1.5pt] (3,0) -- (4.6,4);
\Xterminal{0}{4}{1}{1}{0}{0}
\Xterminal{2}{4}{1}{1}{0}{0}
\Xterminal{4}{4}{1}{1}{0}{0}
\coordinate [label=above: \textsf{X terminals}] (XTerminals) at (2.6,5.5);

\draw[line width=1.5pt] (3,0) -- (8.6,1.6);
\draw[line width=1.5pt] (3,0) -- (8.6,-0.5);
\Workstation{8}{-1}{1}{1}{0}{0}
\Workstation{8}{1}{1}{1}{0}{0}
\coordinate [label=above: \textsf{Workstations}] (Workstations) at (8.6,-2);

\draw[line width=1.5pt] (3,0) -- (0.6,-2);
\draw[line width=1.5pt] (3,0) -- (2.1,-2);
\FileServer{0}{-3}{1}{1}{0}{0}
\FileServer{1.5}{-3}{1}{1}{0}{0}
\coordinate [label=below: \textsf{File servers}] (FileServers) at (1,-3.5);

\draw[line width=1.5pt] (-2.75,-2.5) -- (-4,-2.5);
\coordinate [label=left: \textsf{WAN}] (WAN) at (-4,-2.5);

\draw[line width=1.5pt] (3,0) -- (-2.5,-2.5);
\Server{-3}{-3}{1}{1}{0}{0}
\coordinate [label=below: \textsf{Gateway}] (Gateway) at (-2.7,-3.5);

\draw[line width=1.5pt] (3,0) -- (3.8,-2);
\draw[line width=1.5pt] (3,0) -- (4.8,-2);
\draw[line width=1.5pt] (3,0) -- (5.8,-2);
\Server{3.5}{-3}{1}{1}{0}{0}
\Server{4.5}{-3}{1}{1}{0}{0}
\Server{5.5}{-3}{1}{1}{0}{0}
\coordinate [label=below: \textsf{Login, print and other servers}] (Servers) at (5,-3.5);

\draw[line width=1.5pt] (3,0) -- (-4.8,2);
\ProcessorPool{-5}{0}{1}{1}{0}{0}
\coordinate [label=below: \textsf{Processor pool}] (ProcessorPool) at (-3.85,-0.5);

\TextCloud{3}{1}{2}{2}{0}{0}{\textsf{\begin{large}Local Area Network\end{large}}}

\end{tikzpicture}
\caption{Amoeba architecture.}
\label{amoeba-architecture}
\end{figure}

\section{Objects and Capabilities}
An \emph{object} is described by its \emph{data members} and \emph{operations}. In amoeba every resource is treated as an object. Examples of objects are files, processes, terminals, I/O devices etc. All objects are described and protected by \emph{capabilities}. A capability is a token, key or ticket which provides access to a resource.

\begin{figure}[here]
%\centerline{\includegraphics[]{GPGPU}}
\centering
\begin{tikzpicture}
	\draw[very thick] (6cm, 4cm) rectangle (8cm, 5cm);
	\coordinate [label=above:{\bfseries Server}] (Server) at (7cm,4.25cm);
	
	\draw[thick,<->, >=stealth] (8.1cm,4.5cm) -- (10.8cm, 5.8cm);
	\draw[very thick] (11cm, 5.3cm) rectangle (13cm, 6.3cm);
	\coordinate [label=above:{\bfseries GPU}] (GPU) at (12cm,5.55cm);
	
	\draw[thick,<->, >=stealth] (8.1cm,4.5cm) -- (10.8cm, 4.5cm);
	\draw[very thick] (11cm, 4cm) rectangle (13cm, 5cm);
	\coordinate [label=above:{\bfseries GPU}] (GPU) at (12cm,4.25cm);
	
	\draw[thick,<->, >=stealth] (5.9cm,4.5cm) -- (3.2cm, 5.8cm);
	\draw[very thick] (1cm, 4cm) rectangle (3cm, 5cm);
	\coordinate [label=above:{\bfseries Client}] (Client) at (2cm,4.25cm);
	
	\draw[thick,<->, >=stealth] (5.9cm,4.5cm) -- (3.2cm, 4.5cm);
	\draw[very thick] (1cm, 5.3cm) rectangle (3cm, 6.3cm);
	\coordinate [label=above:{\bfseries Client}] (Client) at (2cm,5.55cm);
	
	\draw[very thick,dotted] (2cm, 2.7cm) -- (2cm, 3.8cm);
	
	\draw[thick,<->, >=stealth] (5.9cm,4.5cm) -- (3.2cm, 2cm);
	\draw[very thick] (1cm, 1.5cm) rectangle (3cm, 2.5cm);
	\coordinate [label=above:{\bfseries Client}] (Client) at (2cm,1.75cm);

\end{tikzpicture}
\caption{Project Overview.}
\label{ProjectOverview}
\end{figure}

\section{Project Phases}

This project is divided into three phases:

\subsection{Phase I: Network Programming}
The first phase is to implement the client--server at application layer. Server should be able to handle multiple clients at a time. It should also be able to support multiple simultaneous connections both to clients and GPU hosts. Server will maintain a dynamic list of computational resources available and those which are in use.

\subsection{Phase II: GPU Programming}
The hosts with GPUs should be able to receive client code and compile it on the fly. In case of errors, appropriate error messages must be relayed to client through server. A mini--compiler can be implemented at the host which can convert conventional loop--based code into appropriate kernel code to be run on GPU. 

Another aspect is multi--GPU computing where a number of GPUs are available to the client. Client can request multiple GPUs in order to speed up the computation. In hybrid multi--GPU context, multiple GPUs running different APIs such as CUDA and OPENCL can be combined to work on a single problem. Synchronization is an important issue in such a scenario.

\subsection{Phase III: Security}
All communication from clients to server to GPU hosts must be secure. Network traffic must be encrypted to keep out eavesdropping. PGP can be a good choice of security. Clients can be assigned usernames/passwords beforehand to only allow trusted access. PGP on top of it can provide additional layer of security if any password(s) are compromised.

\section{Project Timeline}

Major focus will be on the network programming part. Rest of the functionality will depend on robustness and features of client--server application.

Following table provides a tentative timeline for this project:

\begin{table}[h]
\begin{center}
\vspace{0.3cm}
	\begin{tabular}{llp{10cm}}
	\hline \hline
		\textbf{Week} \rule{0pt}{2.6ex} & \textbf{Duration} & \multicolumn{1}{c}{\textbf{Tasks}}\\
		\hline
		2 \rule{0pt}{2.6ex} & 1 week & Set and install network programming APIs on PCs\\
		3 & 1 week & Implement a simple client--server application for handling multiple clients\\
		4-6 & 3 weeks & Implement core features of network programming\\
		7-8 & 2 weeks & Set up GPUs and install GPU programming APIs\\
		9-10 & 2 weeks & Provide GPU programming interface to clients through server over network\\
		11-12 & 2 weeks & Refinements\\
		13-15 & 3 weeks & Encrytion of network traffic and additional security features like PGP\\
	\hline \hline
	\end{tabular}
\end{center}
\label{TimelineTable}
\caption{Project timeline.}
\end{table}
\nocite{*}
\bibliographystyle{ieeetr} %plain, ieeetr
\bibliography{Amoebaref}

%\begin{thebibliography}{99}


%\bibitem{amoeba-sourceforge}
%http://fsd-amoeba.sourceforge.net/amoeba.html

%\bibitem{nVidiaGPGPU}
%George Coulouris, Jean Dollimore \& Tim Kindberg,
% ``Distributed Systems''


%\bibitem{AMDATiGPGPU}
%http://www.amd.com/us/products/technologies/stream-technolo %gy/opencl/pages/gpgpu-history.aspx

%\end{thebibliography}

\end{document}




